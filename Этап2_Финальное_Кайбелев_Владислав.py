### Данная программа выполнена исключительно с помощью циклов и условных операторов, без использования функций
### Она последовательно запрашивает данные у пользователя, с полной проверкой корректности любой вводимой с клавиатуры информации(неправильный формат, пустая строка)
### Работает быстро и надежно
import datetime

print("Добро пожаловать в Менеджер заметок! Вы можете добавить новую заметку")

notes = []  ### Основной список в котором хранятся все заметки в виде словарей
titles = []  ### Список с заголовками заметки

while True:
    ### Ввод имя пользователя и проверка на пустую строку
    username = input("\nВведите имя пользователя: ")
    ### Проверка на пустой ввод
    if len(username.split()) == 0:
        while len(username.split()) == 0:
            print("Вы ничего не ввели. Попробуйте снова")
            username = input("Введите имя пользователя: ")

    ### Данный блок кода позволяет добавлять столько заголовков заметки, сколько потребуется
    print("\nВы можете ввести столько заголовков, сколько желаете!")
    while True:
        print("Чтобы прекратить введите 'стоп'")
        title = input("Введите заголовок: ")

        ### Данное условие проверяет уникальность заголовка
        ### Мы берём введённое значение и проходимся по всему списку, если этот заголовок уже был, то возвращаемся к началу цикла, иначе продолжаем цикл
        if title in titles:
            print("\nЭтот заголовок уже есть")
            continue

        ### Если пользователь вводит слово 'стоп', цикл заканчивается с помощью оператора break
        if title.lower() == 'стоп':
            break

        ### Данное условие проверяет, пустая ли строка.
        ### Нет ни одной буквы, цифры или символа(пробел не считается как символ)
        if len(title.split()) == 0:
            print("\nВы ввели пустую строку, попробуйте ещё раз")
            continue
        else:
            titles.append(title.lower())

        ### Если пользователь вводит слово 'стоп', цикл заканчивается с помощью оператора break
        if title.lower() == 'стоп':
            break
        print()  ### Для красоты вывода

    ### Позже переменная title будет ключом в словаре dict_note, поэтому мы присваиваем ей значения списка titles
    title = titles
    ### Очищаем список для заголовков следующей заметки
    titles = []

    ### Ввод описания заметки и проверка на пустую строку
    content = input("\nВведите описание заметки: ")
    ### Проверка на пустой ввод
    if len(content.split()) == 0:
        while len(content.split()) == 0:
            print("Вы ничего не ввели. Попробуйте снова")
            content = input("Введите описание заметки: ")

    ### Ввод статуса заметки и проверка на пустую строку
    status = input("\nВведите статус заметки (например, 'Новая', 'Активна', 'Выполнена'): ")
    ### Проверка на пустой ввод
    if len(status.split()) == 0:
        while len(status.split()) == 0:
            print("Вы ничего не ввели. Попробуйте снова")
            status = input("Введите статус заметки (например, 'Новая', 'Активна', 'Выполнена'): ")

    ### Данный блок кода выводит текущий статус заметки и позволяет его поменять на один из трех вариантов
    print("Текущий статус в заметке: '" + status + "'")
    ### Создаем бесконечный цикл, чтобы если пользователь введёт неправильный вариант, программа спросит его ещё раз
    while True:
        choosing_a_status = input(
            "\nВыберите новый статус заметки:\n1. Выполнено\n2. Активна\n3. Отложено\nВведите только цифру 1, 2 или 3: ")
        if choosing_a_status == '1':
            status = "Выполнено"
            print("\nТекущий статус заметки: '" + status + "'")
            break
        elif choosing_a_status == '2':
            status = "Активна"
            print("\nТекущий статус заметки: '" + status + "'")
            break
        elif choosing_a_status == '3':
            status = "Отложено"
            print("\nТекущий статус заметки: '" + status + "'")
            break
        else:  ### Если пользователь вводит не тот вариант, его возвращает к началу цикла
            print("\nВы ввели не тот вариант ответа. Попробуйте ещё раз")
            continue

    created_date = input("\nВведите дату создания заметки в формате день-месяц-год: ")
    ### Проверяем формат введённой даты, если пользователь вводит неправильно, конструкция выдаёт ошибку и кидает обратно к началу цикла
    while True:
        try:
            checking_date_format = datetime.datetime.strptime(created_date,
                                                              '%d-%m-%Y')  ### Отдельная переменная для помещения в неё даты в виде класса datetime
        except ValueError:
            print("Вы ввели дату в неправильном формате! Попробуйте ещё раз")
            created_date = input("Введите дату создания заметки в формате день-месяц-год: ")
            continue
        break

    ### Данный блок кода позволяет посчитать количество дней до дедлайна, а также, сегодня ли он или уже истёк
    current_date = datetime.datetime.now()  ### Текущая дата
    issue_date = input("\nВведите дату истечения заметки в формате день-месяц-год: ")
    ### Проверяем формат введённой даты, если пользователь вводит неправильно, конструкция выдаёт ошибку и кидает обратно к началу цикла
    while True:
        ### Проверяем формат введённой даты, если пользователь вводит неправильно, конструкция выдаёт ошибку и кидает обратно к началу цикла
        try:
            issue_date_class_datetime = datetime.datetime.strptime(issue_date,
                                                                   '%d-%m-%Y')  ### Переменная, хранящая в себе дату дедлайна в виде класса datetime
        except ValueError:
            print("Вы ввели дату в неправильном формате! Попробуйте ещё раз\n")
            issue_date = input("Введите дату истечения заметки в формате день-месяц-год: ")
            continue

        ### Проверка дедлайна в настоящем, прошлом и будущем соответственно
        if issue_date_class_datetime.date() == current_date.date():
            print("Ваш дедлайн истекает сегодня!")
        elif issue_date_class_datetime.date() < current_date.date():
            print("Ваш дедлайн истёк!")
            print("Количество дней, когда истёк дедлайн:",
                  (current_date.date() - issue_date_class_datetime.date()).days)
        else:
            print("\nКоличество оставшихся дней до дедлайна:",
                  (issue_date_class_datetime.date() - current_date.date()).days)
        break

    format_date = input(
        "\nВ каком формате показывать дату заметки?\n1. День.месяц.год\n2. День.месяц\nВведите только число, '1' или '2': ")
    ### Проверяет корректность ввода данных и сохраняет вариант ответа в каком виде выводить формат даты далее
    if format_date != '1' and format_date != '2':
        while format_date != '1' and format_date != '2':
            print("Вы ввели не тот вариант ответа. Попробуйте ещё раз")
            format_date = input(
                "В каком формате показывать дату заметки?\n1. День.месяц.год\n2. День.месяц\nВведите только число, '1' или '2': ")

    dict_note = {'username': username, 'titles': title, 'content': content,
                 'status': status, 'created_date': created_date,
                 'issue_date': issue_date, 'format_date': format_date}

    notes.append(dict_note)  ### Добавляем словарь в наш основной список
    print(notes)
    ### Если пользователь, выбирает 'да', то его возвращает к началу программы
    ### Если пользователь, выбирает 'нет', то программа завершает свою работу и выводит все имеющиеся заметки
    ### Если пользователь, вводит что-то не то, программа уведомляет и спрашивает повторно
    answer_option = input("\nДобавить ещё одну заметку? (да/нет): ")
    while answer_option.lower() != 'да' and answer_option.lower() != 'нет':
        answer_option = input("Введите корректные данные. Добавить ещё одну заметку? (да/нет): ")
    if answer_option.lower() == 'да':
        continue

    ### Вложенный цикл, который выводит все заметки из списка
    print("Список заметок:")
    for i in range(0, len(notes)):
        for _ in notes[i]:
            print(f"\nЗаметка №{i + 1}")
            print(f"Имя пользователя: {notes[i]['username']}")
            print(f"Заголовки заметки: {notes[i]['titles']}")
            print(f"Описание заметки: {notes[i]['content']}")
            print(f"Статус заметки: {notes[i]['status']}")
            if '1' in notes[i]['format_date']:
                print(f"Дата создания заметки: {notes[i]['created_date'].replace('-', '.')}")
                print(f"Дата истечения заметки: {notes[i]['issue_date'].replace('-', '.')}")
            elif '2' in notes[i]['format_date']:
                print(f"Дата создания заметки: {notes[i]['created_date'][:5:].replace('-', '.')}")
                print(f"Дата истечения заметки: {notes[i]['issue_date'][:5:].replace('-', '.')}")
            break
    break

### Данный блок кода позволяет удалить заметки, если пользователь того желает, в противном случае программа полностью прекращает свою работу
### Если пользователь вводит неправильно вариант ответа, программа уведомляет его об этом и переспрашивает
while True:
    ### Если основной список с заметками пуст, значит пользователь удалил все заметки и программа заканчивает свою работу
    if len(notes) == 0:
        print("\nДо свидания! Ждем вас снова!")
        break

    answer_option = input("\nЖелаете удалить заметку? (да/нет): ")
    if answer_option.lower() == 'да':
        ### Цикл, выводящий первые три пункта заметки
        for i in range(0, len(notes)):
            for _ in notes[i]:
                print(f"\nЗаметка №{i + 1}")
                print(f"Имя пользователя: {notes[i]['username']}")
                print(f"Заголовки заметки: {notes[i]['titles']}")
                print(f"Описание заметки: {notes[i]['content']}")
                break

        while True:

            ### Переменная для сохранения длины списка
            len_notes = len(notes)

            ### Цикл удаляет весь словарь с заметкой по её названию или имени пользователя
            deleting_note = input("\nВведите имя пользователя или заголовок для удаления заметки: ")
            for j in range(0, len(notes)):
                if deleting_note.lower() == notes[j]['username'].lower() or deleting_note.lower() in notes[j]['titles']:
                    notes.pop(j)
                    break

            ### Если длина списка равна нулю, значит пользователь удалил все заметки, программа уведомляет об этом и заканчивает свою работу
            if len(notes) == 0:
                print("Успешно удалено. Заметок больше не осталось.")
                break

            ### Если длина списка не изменилась после цикла, значит пользователь ввёл не те данные, и его возвращает с началу
            ### Если длина списка изменилась, значит что-то удалилось и это условие код пропустит
            if len(notes) == len_notes:
                print("\nЗаметок с таким именем пользователя или заголовком не найдены. Попробуйте снова")
                continue

            print("Успешно удалено. Остались следующие заметки:")
            ### ### Цикл, выводящий первые три пункта заметки
            for i in range(0, len(notes)):
                for _ in notes[i]:
                    print(f"\nЗаметка №{i + 1}")
                    print(f"Имя пользователя: {notes[i]['username']}")
                    print(f"Заголовок заметки: {notes[i]['titles']}")
                    print(f"Описание заметки: {notes[i]['content']}")
                    break

            ### Если пользователь вводит что-то помимо 'да' или 'нет', программа уведомляет его об этом и переспрашивает, пока не будет введён правильный вариант ответа
            ### Если пользователь вводит 'да', то программа возвращает его обратно к началу цикла
            ### Если пользователь вводит 'нет', то программа заканчивает свою работу
            answer_option = input("\nУдалить ещё одну заметку? (да/нет): ")
            while answer_option.lower() != 'да' and answer_option.lower() != 'нет':
                answer_option = input("Введите корректные данные. Удалить ещё одну заметку? (да/нет): ")
            if answer_option.lower() == 'да':
                continue
            elif answer_option.lower() == 'нет':
                print("\nДо свидания! Ждем вас снова!")
                exit()
            break
    elif answer_option.lower() == 'нет':
        print("\nДо свидания! Ждем вас снова!")
        break
    else:
        print("Введите корректные данные.")
        continue
